# Networking. TCP/IP Basics, DNS, what is HTTP, how to setup some web server with some web backend (php-fpm, apache, nginx, so on) PHP/LAMP setup 2  
## Модель OSI
![Модель OSI](https://lanmarket.ua/upload-files/1/20080403153257Osi-model.png)
## TCP/IP
> TCP/IP — сетевая модель передачи данных, представленных в цифровом виде. Модель описывает способ передачи данных от источника информации к получателю. В модели предполагается прохождение информации через четыре уровня, каждый из которых описывается правилом (протоколом передачи). Наборы правил, решающих задачу по передаче данных, составляют стек протоколов передачи данных, на которых базируется Интернет. Название TCP/IP происходит из двух важнейших протоколов семейства — Transmission Control Protocol (TCP) и Internet Protocol (IP), которые первыми были разработаны и описаны в данном стандарте. Также изредка упоминается как модель DOD в связи с историческим происхождением от сети ARPANET из 1970-х годов (под управлением DARPA, Министерства обороны США).

> (c) wikipedia


## Адресация

Как уже было сказано, для работы в сети нужна адресация. В условиях сетей **TCP/IP** эта адресация задумывалась исходя из следующих соображений:
- Компактность в памяти
- Достаточно большой диапазон адресов
- Иерархичность

### Виды адресов

*Серые* (локальные) - адреса:
```
192.168.0.0/16
172.16.0.0/12
10.0.0.0/8
100.64.0.0/10
```

Серые адреса могут употрябляться только в локальных сетях, и к ним невозможно достучаться из сети интернет, так как в мире существует множество локальных сетей с локальными адресами.

Вы можете посмотреть список интерфейсов и их адресов с помощью утилит `ip a` и `ifconfig`

### IP адрес

В **IPv4** используются адреса из 4 байт, который обычно записываются в десятичной форме:
```
192.168.1.1
8.8.8.8
159.224.15.224
```

и т. д.

## Роутинг
Для маршрутизации адреса разбиваются на группы, которые называют адресом сети. Остальная часть адреса - адрес узла в подсети.
Для просмотра и конфигурации используются настройки интерфейса и утилиты `route` и `ip r`.
### Маска

Для этого разделения служит битовая маска, называемой маской подсети. Двоичные единицы в ней означают адрес сети, двоичные 
нули - часть, отвечающая за адрес узла в подсети.

При роутинге маска накладывается на тот или иной адрес. и если адрес подсети другой, то данные отправляются на интерфейс с этим
адресом подсети или на маршрутизатор.

Например:

```
Адрес: 192.168.1.2
Маска: 255.255.255.0
Роутер: 192.168.1.1
```

При отправке пакета на адрес 8.8.8.8 адрес маскируется маской 255.255.255.0 с помощью операции AND (`&`), в результате
чего получается адрес сети 8.8.8.0. Адрес сети не совпадает с родной сетью 192.168.1.0, а значит пакет отправляется
на маршрутизатор 192.168.1.1, который должен направить его далее в интернет.

Если же вы будете обращаться по адресу 192.168.1.*, то после применения маски к адресу адресата у вас получится
тот же адрес, что и адрес вашей сети (192.168.1.0), и пакет будет направлен непосредственно адресату в этой локальной сети.

Так же маска может обозначаться с помощью длины блока единиц в маске:
```
192.168.0.0/16 означает
192.168.0.0 и маску 255.255.0.0
```

## NAT

**N**etwork **A**ddress **T**ranslation - система, благодаря которой компьютеры с локальными адресами за маршрутизатором могут
получать данные из сети интернет, несмотря на то, что серые адреса недоступны из глобальной сети.

Для реализации этого механизма маршрутизатор подменяет обратный адрес на свой глобальный и заводит специальную таблицу
соответствия внешних и внутренних соединений. Таким образом, ответ из глобальной сети приходит на внешний адрес маршрутизатора
после чего маршрутизатор обратно подменяет адрес назначения на локальный адрес. 

Для настройки используется стандартный firewall `iptables`.

## DNS
Резольвер и его конфигурация.

**DNS** - глобальная распределенная база данных для хранения информации о доменных именах. Непосредственно
сетевые соединения не используют эти имена, для создания соединения вначале надо провести процедуру
**разрешения** (resolving) - преобразование имя домена в IP адрес для дальнейшей работы.

Для работы с **DNS** используются утилиты `whois`, `dig` и `host`

Для того, что бы на локалхосте добавить свой личный домен можно отредактировать файл `/etc/hosts`
После этого с текущего компьютера вы сможете ходить по вашим фейковым доменам, даже если их нет 
в глобальном DNS.

По умолчанию список **DNS**-серверов, которые обеспечивают вас IP адресами и прочими настройками
доменов находится в файле `/etc/resolv.conf`.

## Сетевой сокет

Двунаправленный поток данных между двумя сетевыми адресами называют **сокетом**. Так как одновременно
может существовать несколько потоков между адресами, то кроме адресов, сокеты идентифицируются
номером порта.

### Номер порта.

16битное число (0..65535), которое идентифицирует сервис на сервере (22 - ssh, 80 - HTTP, и т.д. ), или
же соединение с тем или иным сервисом. Когда вы открываете вкладку в браузере, соединение имеет не только
порт и адрес назначения, но и исходящий адрес и порт, на который сервер шлет ответ. Операционная система
выделяет исходящие порты автоматически.

Порты 0..1023 являются привелигированными. 

### Слушатель (сервер)

В **POSIX** системах есть понятие слушающего сокета. Это не соединение как таковое, а 
декларация операционной системе, что данный порт на данном интерфейсы занят под тем
или иным сервисом, и при возникновении входящего соединения именно этому сервису надо
отдать новое соединение. Таким образом работает подавляющее большинство сервисов
типа **Apache**, **NGINX**, **ProFTPd** и так далее. Слушающий сокет позволяет
создавать множество соединений на один и тот же адрес и порт.

### Обычное соединение (исходящее)

При соединении с удаленным адресом и портом ОС выдает рандомный исходящий
порт и подходящий интерфейс, через который инициируется соединение.
В дальнейшем ответы приходят на этот адрес и порт. Пара адреса и порта
может использоваться промеждуточным **NAT** маршрутизатором
для подмены адреса и порта при исходящих и входящих пакетах.


## PHP

Исторически **PHP** работал, используя **CGI**, Common Gateway Interface.

При каждом запросе **веб-сервер**:
- Принимал соединение, определял по адресу или конфигурации, что данный запрос является **CGI**
- Создавал набор переменных окружения (например данные в `$_SERVER` попадают из переменных окружения) с характеристиками запроса
- Запускал процесс, обрабатывающий **CGI** запрос, передавая ему на стандартный ввод тело **HTTP** запроса
- Процесс обрабатывал **HTTP** запрос, стандартный вывод процесса перенаправлялся **веб-сервером** клиенту в браузер. По окончанию обработки запроса процесс прекращал свою работу.

Именно из **CGI** **PHP** унаследовал модель работы *Designed To Die*.

### Современные интерфейсы между **PHP** и **веб-сервером**

#### FastCGI

**FastCGI** - современная, улучшенная версия **CGI**, в которой:
- Для ускорения обработки запросов *процессы не запускаются при каждом запросе, а постоянно работают, обрабатывая множество запросов*
- Общение с процессом происходит не через стандартные потоки ввода-вывода, а через сокеты (сетевые соединения или сокеты в файловой системе), что позволяет разнести **FastCGI** процессы на множество других серверов

Однако некоторые недостатки **FastCGI** привели к появлению...

#### PHP FastCGI Process Manager (php-fpm)

Улучшенный **FastCGI**. Этот способ в основном используется в связке с **nginx**

#### `mod_php`

Классика, самый обычный способ конфигурации **PHP** с **веб-сервером** **Apache**. Кодовая база **PHP** подключается как модуль **веб-сервера** и работает "изнутри" веб-сервера. Достоинство этого подхода в простоте настройки и скорости работы. Недостатки же 
вытекают из достоинств: слабая масштабируемость, зависимость от **веб-сервера**, меньшая безопасность, отсутствие возможности гибко конфигурировать версии **PHP**.

## Apache

Часто используемый для обычных проектов и разработки **веб-сервер**. **PHP** обычно неплохо работает с настройками по умолчанию.

### Основные настройки

Для подключения **PHP** в настройках где-то (обычно в /etc/apache2/) должна быть следующая строка, или строка, подобная этой:

```
LoadModule php5_module modules/mod_php.so
```

Эти же строки добавляют связь между расширением файла и модулем php для обрабоки этих файлов:

```
<FilesMatch "\.(php|php[57]|phtml)$">
    SetHandler application/x-httpd-php
</FilesMatch>
```

`DirectoryIndex` указывают **веб-серверу**, что кроме `index.html` нужно обрабатывать и `index.php`:

```
    DirectoryIndex index.php index.phtml
```

### Virtual mass hosting

Работает как модуль mod_vhost_alias. Перед настройкой убедитесь что этот модуль подключен.

Обычно в дистрибутивах linux с apache домены настраиваются путем копипасты конфига домена в папке на подобие /etc/apache2/sites.d/. Возможна так же папка /etc/apache2/sites.enabled.d/ в которой хранятся симлинки на включенные сайты. Сайты из sites.d без симлинка в этой папке
выключены. Enabled сайты подключаются в основной конфиг apache через директиву Include (в конце файла).

Однако есть **альтернатива**: **Virtual mass hosting**.

Этот способ отличается упрощенным созданием и удалением доменов. Работает он благодаря следующим возможностям **DNS** и **apache2**:

- В DNS конфигурации прописывается звездочка для поддомена: *.dev.galera.com ссылается на IP-адрес вашего сервера с apache2. Таким образом *любой* поддомен типа superproject.dev.galera.com будет адресован на один сервер.
- На этом сервере имя поддомена превращается в имя папки, из которой беруться файлы сайта.

```
# get the server name from the Host: header
UseCanonicalName Off

# this log format can be split per-virtual-host based on the first field
# using the split-logfile utility.
LogFormat "%V %h %l %u %t \"%r\" %s %b" vcommon
CustomLog "logs/access_log" vcommon

# include the server name in the filenames used to satisfy requests
VirtualDocumentRoot "/www/hosts/%0/docs"
VirtualScriptAlias  "/www/hosts/%0/cgi-bin"
```

Вместо $0 подставляется имя сервера из HTTP-заголовка. Таким образом создание нового поддомена для проекта сводится к созданию директории с именем домена.

Есть так же другие переменные, %1, %2 и так далее:
- %1 - первый поддомен ("www" в "www.google.com", "superproject" в "superproject.dev.galera.com")
- %2 - второй поддомен ("google" в "www.google.com", "dev" в "superproject.dev.galera.com")

Таким образом вы можете использовать более удобные имена директорий.

Подробнее: https://httpd.apache.org/docs/2.4/vhosts/mass.html

### `.htaccess`

Эти файлы являются способом установки локальных настроек для директории и её поддиректорий. Синтаксис в них такой же как и в других конфигах **apache**. Для изменения настроек **PHP** вы можете использовать директиву `php_value` согласно синтаксису `php.ini`.

#### `mod_rewrite`

Еще один модуль **apache** для отвязывания адреса URL от реальной файловой системы. Часто вызывает боль при попытках отладить сложные конфигурации. Для отладки можно включить логгирование, но **только** при конфигурировании `mod_rewrite` в конфиге **apache**, а не в 
`.htaccess`.

Данную опцию надо занести в конфиг виртуального хоста, поэтому он несовместим с Mass Virtual Hosting:
```
LogLevel alert rewrite:trace3
```

Умолчательный .htaccess для перенаправления всех запросов к index.php для дальнейшего роутинга средствами MVC-фреймворка:

```
RewriteEngine on
# If a directory or a file exists, use the request directly
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
# Otherwise forward the request to index.php
RewriteRule . index.php [L]
```

**Учтите**, что для работы .htaccess вы должны разрешить изменения конфигурации для конкретной директории. Делается это с помощью
следующих настроек веб-сервера в секции Directory:

```
AllowOverride all
Require all granted
```

Однако в целом **Apache** изначально задуман для отображения папок реальных файлов, и данные костыли выглядят чужеродно. Более органичен для таких целей **NGINX** и **PHP-FPM**.

## NGINX

Легковесный быстродействующий веб-сервер, популярный для высоконагруженных решений. Конфигурация скорее настраивает доменные имена и их обработчики, чем файлы и директории. В этом контексте **NGINX** является **reverse-proxy**, т. е. фасадом перед реальным веб-сервером,
обрабатывающим запросы. Тем не менее NGINX без проблем раздает файлы и может сильно оптимизировать раздачу статики и загрузку файлов. На данный момент в NGINX даже есть внутренний скриптовый язык, базированный на **JS**.

### `php-fpm`

Типичная конфигурация **nginx+php** реализуется через **php-fpm**. В отличие от **Apache**, в котором **mod_php** является частью процесса веб-сервера, при работе с **php-fpm** нужно два процесса (демона), которые обрабатывают запросы. Первый - **веб-сервер**, который
обрабатывает входящие запросы, привязывает веб-приложение к домену, зачастую отдает статические файлы и так далее. Второй процесс - сервер приложения, к которому **веб-сервер** обращается для обработки запросов. 

#### Конфигурация `php-fpm`

Файл php-fpm.conf хранит основные настройки:

```
user = nobody
group = nobody
listen = 127.0.0.1:9000

pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
```

- `user,group` - пользователь и группа, из под которых будет запускаться сервер приложений
- `listen` - адрес и порт. Обычно используется 127.0.0.1 для безопасности. Запомните эти параметры.
- pm... - настройки процессов, количество обработчиков запросов и т. д.

#### NGINX

```
server {
       listen 164.138.30.21; //внешний IP
       server_name yieldmap.helium.asmer.org.ua; //домен

       root /var/www/gorobets/yieldmap.helium.asmer.org.ua; //DocumentRoot
                               
       location / { //корень сайта
               try_files $uri $uri/ /index.php;
               autoindex on;
       }
        location ~ \.php$ { //все PHP на fpm
             include /etc/nginx/fastcgi.conf;
             fastcgi_pass unix:/run/php-fpm.socket;
             fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
             fastcgi_index index.php;
       }
}
```

параметром `fastcgi_pass` указывается сокет в файловой системе (или сетевой, 127.0.0.1:9000, например)

## `php.ini`

Это файл конфигурации собственно php. Большинство настроек можно узнать используя `phpinfo()` в коде.

> Учтите, что для каждого варианта запуска php скорее всего будет *свой* php.ini. Т. е. настройки, которые работают в консоли, вовсе не обязательно что совпадают с mod_php или php-fpm. 

Важные конфигурационные параметры:

```
short_open_tag = Off
```

Опция включает или выключает короткие php-тэги `<?` и `?>`

```
max_execution_time = 30
```

время работы скрипта. Имеет смысл для разгрузки веб-серерва и никакого смысла для работы скриптов в консоли.

```
memory_limit = 128M
```

Лимит памяти. Может грохнуть скрипт, который ворочает большим объемом данных, например генерирует прайс в xls, или ORM по большому набору данных в БД.

```
error_reporting = E_ALL
```

Какие ошибки логгировать.

```
display_errors = On
```
Показывать ошибки в выводе или нет. Удобно видеть ошибки в перемешку с HTML при отладке, но недопустимо в продакшене.

```
log_errors = On
```

Опция полезна для записи ошибок в лог-файл на продакшене

## `Forbidden` и права доступа

Учтите, что для работы вашего проекта, нужно что бы файлы были доступны для соответственного процесса. Например, если вы отдаете статику с помощью **NGINX**, а php обрабатываете через **php-fpm**, вы должны удостовериться, что у этих процессов
доступ к статическим и PHP-файлам соответственно.

## Логи

Логи - это важно и интересно. Обычно находятся в `/var/log/apache*/*`, `/var/log/nginx/*`, `/var/log/php*/*`


## NGINX

`To be continued`
