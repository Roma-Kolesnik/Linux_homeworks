# Microservices VS Monolith


## Микросервисная архитектура
![](http://blog.newrelic.com/wp-content/uploads/microservices.jpg)

Если коротко, то **архитектурный стиль микросервисов** — это подход, при котором единое приложение строится как набор небольших сервисов, каждый из которых работает в собственном процессе и коммуницирует с остальными используя легковесные механизмы, как правило **HTTP**. Эти сервисы построены вокруг бизнес-потребностей и развертываются независимо с использованием полностью автоматизированной среды. Существует абсолютный минимум централизованного управления этими сервисами. Сами по себе эти сервисы могут быть написаны на разных языках и использовать разные технологии хранения данных.

### Например

Есть некое приложение, например [CRM](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B0_%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F_%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%BE%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8_%D1%81_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D0%B0%D0%BC%D0%B8) система(сайт)

Предположим что она имеет такие основные части:
    - Система авторизации пользователя(логинка)
    - Основное приложение
    - Система разгранечение допуступа по ролям(RBAC)
    - Система сбора аналитики
    - Система создания отчетов
    - База Данных

![](http://linuxlectures.asmodeus.php2.a-level.com.ua/microservices.jpg)

Каждый из представленых частей(сервисов) работают в связке между собой но при этом являются полноценной рабочей еденицой в приложении.
То есть каждый сервис может работать отдельно от остального мира и не влиять на работу других сервисов. Таким образом если какой-то из сервисов выходит из строя то он не влияет на работу остальных сервисов.



## Монолитная архитектура
![](https://www.slashroot.in/sites/default/files/Monolithic%20Application%20Architecture.png)

Монолитный сервер — довольно очевидный способ построения подобных систем. Вся логика по обработке запросов выполняется в единственном процессе, при этом вы можете использовать возможности вашего языка программирования для разделения приложения на классы, функции и namespace-ы. Вы можете запускать и тестировать приложение на машине разработчика и использовать стандартный процесс развертывания для проверки изменений перед выкладыванием их в продакшн. Вы можете масштабировать монолитное приложения горизонтально путем запуска нескольких физических серверов за балансировщиком нагрузки.

### Например

Пример нашей CRM в монолитном представлении

![](http://linuxlectures.asmodeus.php2.a-level.com.ua/Monolith.jpg)

Тут видна связка из модулей внтури одной большой системы которые работают между собой. В таких системах модульность организовываться на уровне ЯП.
Так или иначе такая система становиться большой и неповоротливой, внесение изменений становиться болезненым а замена модулей вызывает очень большие проблемы. После таких изминений приходиться тестировать весь функционал заново.



# Что такое Docker?

![](https://xakep.ru/wp-content/uploads/2015/06/docker_usage1.jpg)

Докер это программа которая контейниризирует ваш софт скрывая его от всего остального мира, таким образом обеспечивая полную изоляцию от остальной системы позволяя вам делать в этой среде то что вам необходимо(например ставить другие программы нужных вам версий без влияния на основную систему)

В современном девелопменте докер является одним из инструментов который позволяет реализовать микросервисную архитектуру.

Докер это не одна виртуалка как например Vagrant.
По сути каждый контейнер это процесс в вашей ОС который изолирован от всех остальных процессов. Таким образом вы можете запускать несколько контейнеров в котором может работать любое количество приложений(например PHP, NGINX, MySQL).

Например в одном контейнере у вас может работать Apache или Nginx, в другом работать PHP и Mysql и вы имеете возможность передавать информацию с одного контейнера к другому.

## Что позволяет сделать Docker?

С помощью Docker можно упаковать любое приложение в контейнер с минимальным количеством зависимостей необходимых для нормального функционирования приложения.

Так же Docker изолирует приложения от основной системы что позволяет иметь меньше проблем с зависимостями и версиями пакетов.

В состав программных средств входит демон — сервер контейнеров, клиентские средства, позволяющие из интерфейса командной строки управлять образами и контейнерами.

Демон обеспечивает полную изоляцию запускаемых на узле контейнеров на уровне файловой системы (у каждого контейнера собственная корневая файловая система), на уровне процессов (процессы имеют доступ только к собственной файловой системе контейнера, а ресурсы разделены средствами libcontainer), на уровне сети (каждый контейнер имеет доступ только к привязанному к нему сетевому пространству имён и соответствующим виртуальным сетевым интерфейсам).

## Установка Docker
[Ubuntu Linux](https://docs.docker.com/install/linux/docker-ce/ubuntu/)


[MacOS](https://docs.docker.com/docker-for-mac/install/)


[Windows](https://docs.docker.com/docker-for-windows/install/)



**ВАЖНО!!!**

Для того что бы ваш докер работал от имени пользователя(без sudo)
необходимо вашего пользователя добавить в группу `docker`.

Делается это так - 

`sudo usermod -aG docker $USER`

После чего закройте все консоли и откройте заново и попробуйте запустить команду `docker run hello-world`.

Если у вас ошибка `Cannot connect to the Docker daemon. Is the docker daemon running on this host?` то закройте все терминалы, если не получается то перезагрузите ваш компьютер.


## Как это работает?

В отличии от полноценных ОС в докере не требуется все настраивать отдельно.

Вся настройка происходит в одном файле, в котором вы пишите сценарий при котором будут скачиваться и запускаться необходимые приложения.

Такой файл называется `Dockerfile`

В нем описываются шаги которые настраивают ваш контейнер.

Простой пример Dockerfile

```yml
FROM php:7.0-apache

RUN apt-get update && \
    apt-get install -y php5-mysql && \
    apt-get clean

COPY myapp /var/www/html/
```

Докер просматривает файл строчку за строчкой и на основе этих действий собирает вам образ который вы можете переиспользовать.


[Пример](http://gitlab.a-level.com.ua/yozh/lamp-docker/src/master/Dockerfile) LAMP в докере


### Каким образом устанавливается тот или иной линукс в докере?

У Docker имееться свой репозиторий со специально подпилеными дистрибутивами а так же уже готовыми окружениями и/или уже собраным софтом

[Docker Hub](https://hub.docker.com/explore/)

Так же создав свой неповторимый контейнер его можно залить в Hub и потом очень быстро собрать на новой системе.

Контейнер на этапе сборки скачивает все необходимое из репозитория в том числе образ ОС.

Такие образы могут весить от 200MB до 1.5 GB. Все зависит от потребностей.

Так же Docker ест оперативную память не хуже Google Chrome, имейте это ввиду

## Основные команды для управлением процесса сборки конейтнера

1. Для начала необходимо создать дерикторию в которой мы будем собирать контейнер.

2. Создаем в ней `Dockerfile` именно в таком регистре и никак иначе.

3. В самом `Dockerfile` первой строчкой обычно указывается какой образ системы будет установлен.
   * На примере [LAMP](http://gitlab.a-level.com.ua/yozh/lamp-docker/src/master/Dockerfile) разберемся с основными командами
   * Первое это `FROM ubuntu:16.04` - указывает какой образ ОС будет скачан и использоваться для нашего контейнера.
   * Далее `RUN apt-get update` - команда __RUN__ запускает внутри контейнера ту или иную команду оболчки.
   * После следует этап установки зависимостей. Тут как в обычном линуксе мы указываем через `RUN` что сделать что бы поставить программы которые нам нужны для успешной работы приложения.
   * После большого количества __RUN__ появляеться новая команда `ENV` - она отвечает за переменные окружения которые могут понадобиться программам которые мы установили. Например `APACHE_LOG_DIR /var/log/apache2` устанавливает основную папку для хранения логов Apache.
   * После установки всех нужных нам переменных окружения вы можете увидеть `ADD`. Эта команда копирует из дериктории какой-то файл который находиться в одной папке  Dockerfile. В данном случае копирует настройки супер визора.

__Важно!__
   Docker не имеет доступа к файловой системе выше чем на один уровень. Если ваш файл конфигурации лежит не в дериктории с `Dockerfile` то могут возникнут неопредолимые трудности.
   
   * Далее после цепочки `RUN` мы видим `VOLUME`. __VOLUME__ это монтируемый раздел который будет примонтирован к контейнеру


### VOLUME

Докер контрейнер собирается один раз и все изминения которые в нем происходят никак не записываются.
Например если у вас есть база данных в контейнере то после перезапуска онного вы получите пустую базу по причине что докер использует уже готовый собраный образ системы.

Есть необходимость каким то образом запоминать изминения и после перезагрузки не терять их.

Механизм который может реализовать сохраненине данных являются Volumes.

Если кратко то это просто шареная(sharing) папка. То есть у вас есть некая папка на вашей основной система в которую докер может сохранять какие то файлы, например файлы базы данной.

Volume это монтируемый раздел. Он будет примонтирован после успешной сборки контейнера.

Для таких целей можно смонтировать дерикторию в которую docker будет складывать файлы. 

![](https://docs.docker.com/storage/images/volumes-shared-storage.svg)


* Команда `VOLUME` выбрасывает наружу раздел который можно примонтировать к какой то папке.
4. `EXPOSE` выбрасывает наружу порты.
5. `CMD` это команда которая будет что то запускать когда загрузиться сам контейнер, например это может быть старт вашего приложения


## Основные команды управление контейнером

* Сборка контейнера `docker build -t container-name .` - `-t` опция указания тега для названия контейнера. Точка это указание на дерикторию где необходимо искать `Dockerfile`

* Запуск контейнера осуществляется командой `docker-run tagname/IMAGEID`. После сборки вашему образу контейнера будет выдан IMAGEID. Его можно запускать как через IMAGEID так и через tagname

* Дополнительных параметров запуска тьма тьмущая. Розберем запуск LAMP контейнера `docker run -t -d -p 80:80 -p 3306:3306 -v /var/www:/var/www/html IMAGEID`

Мы говорим докеру запустить контрейнер с тегом(`-t`) в свернутом режиме(`-d`) с пробросом порта(`-p`) где __80__ внутренний порт контейнера мы выкидываем на наш внеший то есть локальный порт 80(apache http port), потом так же выбрасываем наш mysql для того что бы мы могли подключаться к mysql с найшей локальной машины не заходя в сам контейнер.

* Просмотр состояине запущеных контейнеров `docker ps`

* остановка контейнера `docker stop tagname/IMAGEID`

* Доступ к шелу контейнера `docker exec -it “container-id” /bin/bash`


