## ОС(Операционная Система)

__Операционная система__ - программный комплекс, который предназначен для управления аппаратурой компьютеров и предоставления стандартного набора возможностей ([API](https://ru.wikipedia.org/wiki/API)) приложениям.

### Задачи, которые берет на себя ОС

* Управление аппаратурой, драйвера устройств, предоставление программных интерфейсов для работы с аппаратурой.

Программное обеспечение с помощью которого ОС получает доступ к аппартному обеспечению(памяти, подключенным устройствам, процессору, сетевой карте и т.д)


Например взамодействие с сетью. На уровне ОС - доступ к сети осуществляется унифицированым способом для любой программы. Программе которая работает в ОС не нужно знать тонкости реализации сетевой карты для того что бы сделать запрос на сервер, этим занимаются драйвера для этой карты.


* Совместный доступ к ресурсам компьютера для разных одновременно работающих приложений



В ОС работает большое количество программ одновременно и всем надо выделять ресурсы(память, дисковое пространство и т.д) для корректной работы этих самых программ.

Основные ресурсы которые выделяются для работы программ:

* Место на жестком диске

* Оперативная память

* Вычислительная мощность процессора

* Сетевой канал для обмена данными

#### Основные уровни абстракции ОС на упрощеном примере Unix подобных систем

![alt text](http://linuxlectures.asmodeus.php2.a-level.com.ua/oslayers.jpg)

### Файловая система

__Файловая система__ - древовидная база данных, предназначенная для хранения файлов и директорий. Файловые системы обычно работают с энергонезависимыми носителями (HDD, SSD), однако в UNIX-системах файловые системы бывают еще виртуальные или, например, в ОЗУ, что, временами, очень удобно. Файловые системы бывают разные, но обычно они привязаны к одному носителю (диск, память, удаленный доступ по сети), имеют лимитированный объем, хранят в себе полезную информацию (в файлах) и, собственно, информацию о структуре файловой системы (имена файлов, права доступа, дерево директорий и т.д.)

![alt text](https://pcsecrets.ru/wp-content/uploads/2015/06/22_Linux.002.jpg)


### Пользовательский интерфейс

#### GUI

На текущий момент на рынке интерфейсов победили GUI (Graphical User Interface) - те или иные графические интерфейсы, ориентированные на работу с тачскрином или мышью. Удобные и интуитивные для пользователя, они плохо подходят для автоматизации действий, так как предполагают наличие оператора, который будет находить и нажимать нужные кнопки на экране.


Gnome and Unity(Linux)

![gui linux](https://www.linux.com/sites/lcom/files/styles/rendered_file/public/gnome-unity-main.jpg?itok=BO1W6ogf)


Windows XP

![win xp](https://upload.wikimedia.org/wikipedia/ru/8/8f/Windows_XP_SP3.png)


KDE(Linux)
![kde hz](https://cn.pling.com/img/1/2/a/1/ba80bcaee6c0f6f3683795da903be2242d5d.png)



### CLI (Command Line Interface)

CLI (Command Line Interface) - интерфейс командной строки, который предполгает взаимодействие с программами путем ввода команд и получение текстового результата работы команды. Данный способ не так интуитивен, как GUI, однако у него есть огромный плюс - команды могут вводится вслепую, а значит для запуска нескольких команд подряд вовсе не обязателен человек, смотрящий в экран. По этой причине задачи, выполняемый в CLI легко автоматизируются - достаточно предусмотреть механизм, который позволит запускать несколько команд последовательно из текстового файла или иного источника. Более того, современные командные интерфейсы (bash, zsh, powershell) являются вполне полноценными языками программирования. sh и bash вообще стояли у истоков многих языков программирования наподобие perl и php.

![mac os](https://www.nexmo.com/wp-content/uploads/2016/06/nexmo-cli-installed.jpg)

![open cv](http://78.media.tumblr.com/6f8537481aaf29b37b84c9027009c4d4/tumblr_inline_nvv3cgAmYz1sy21jn_540.png)

![windows](http://www.thatjeffsmith.com/wp-content/uploads/2013/07/sdcli1.png)


### Linux VS Windows

Плюсы Linux:

	- Бесплатно
	- Секурно(99% вирусов не запускаются под линуксом)
	- Расширяемо(может работать распределенно на больших кластерах)
	- Сужаемо(работает даже на вашем домашнем роутере)
	- Переносимость
	- Открытый исходный код
	- Большое количество открытого и бесплатного софта
	- Все можно настроить. Да-да, Все!
	- Выпрямляет руки
	- После установки ready to use
	
Минусы:
	
	- Нет игр
	- Популярный графический мультимедиа софт не работает(Adobe, Autodesk, VegasPro, etc)
	- Бывают баги и что то падает
	- Все нужно настраивать!
	- Со старту не такой уж и user friendly
	- Слишком большое количество дистрибутивов в котором можно запутаться
	- Не прощает ошибок
	

Плюсы Windows:

	- Много софта для любых мультимедиа задач(Adobe, Autodesk, Kompas3D, etc)
	- Большое количество игр
	- Работает даже на самом экзотическом железе
	- Огромный набор графического софта под любые задачи
	- Ее можно крякнуть :)
	- Даже бабушка осилит

Минусы:

	- Зависимость от одной компании
	- Занимает много памяти и ресурсов
	- Нет CLI(CMD.exe и Powershell не в счет)
	- Привязаность к графическому окружению
	- Большое количество вредноносного ПО
	- Со старта даже браузера нормального нет
	- Не переносимая от слова совсем
	- Ограничена в настройке
	- Файловая система(NTFS) закрытая и в разы медленнее чем линуховая(ext4)
	- Не оставляет шансов старым компьютерам


###  Какой же линукс выбрать?!

![distros](https://linuxhere.files.wordpress.com/2010/08/lintimeline2.png)

Мейнстрим:
* [Ubuntu Linux](https://www.ubuntu.com/download/desktop)
* [Linux Mint](https://www.linuxmint.com/download.php)
* [Debian Linux](https://www.debian.org/CD/torrent-cd/)
* [Fedora](https://getfedora.org/ru/workstation/)

Для любителей экзотики:
* [Arch Linux](https://www.archlinux.org/download/)
* [Gentoo Linux](https://www.gentoo.org/downloads/)
* [Sabayon Linux](https://www.sabayon.org/download/)
* [Manjaro Linux](https://manjaro.org/get-manjaro/)

	
#### Семейства Дистрибутивов

Эти дистрибутивы стали базой для других не менее известных дистрибутивов:

| Debian based  | Red Hat based    | ArchLinux based | Gentoo based    |
|---------------|------------------|-----------------|-----------------|
| Ubuntu        | Fedora           | ArchBang        | Calculate Linux |
| Linux Mint    | CentOS           | Arch Hurd       | Sabayon         |
| Kali Linux    | Scientific Linux | Elegance        | Zentoo          |
| Elementary OS | Oracle Linux     | Chakra          | Chromium OS     |



полный список дистрибутивов можно найти на сайте [Distrowatch](https://distrowatch.com/?language=RU) а так же на [Педивикии](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B4%D0%B8%D1%81%D1%82%D1%80%D0%B8%D0%B1%D1%83%D1%82%D0%B8%D0%B2%D0%BE%D0%B2_Linux)





### Общая структура файловой системы linux/unix/posix.

**Файловая система** - древовидная база данных, предназначенная для хранения *файлов* и *директорий*. Файловые системы обычно работают с энергонезависимыми 
носителями (**HDD**, **SSD**), однако в **UNIX**-системах файловые системы бывают еще виртуальные или, например, в **ОЗУ**, что, временами, очень удобно.
Файловые системы бывают разные, но обычно они привязаны к одному носителю (диск, память, удаленный доступ по сети), имеют лимитированный объем, хранят
в себе полезную информацию (в файлах) и, собственно, информацию о структуре файловой системы (имена файлов, права доступа, дерево директорий и т.д.)

![linux tree](https://i.pinimg.com/originals/ab/06/70/ab0670ef648900b04d7a37d7a5b5ba0a.png)

<table>
<thead>
<tr>
<th>Директория</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr><td>/</td><td>корень</td></tr>
<tr><td>/bin</td><td>(binaries) бинарные файлы пользователя</td></tr>
<tr><td>/sbin</td><td>(system binaries) системные исполняемые файлы</td></tr>
<tr><td>/etc</td><td>(etcetera) конфигурационные файлы</td></tr>
<tr><td>/dev</td><td>(devices) файлы устройств</td></tr>
<tr><td>/proc</td><td>(proccess) информация о процессах</td></tr>
<tr><td>/var</td><td>(variable) Переменные файлы</td></tr>
<tr><td>/var/log</td><td>Файлы логов</td></tr>
<tr><td>/var/lib</td><td>переменные библиотеки</td></tr>
<tr><td>/var/mail</td><td>почта</td></tr>
<tr><td>/var/spool</td><td>принтер</td></tr>
<tr><td>/var/lock</td><td>файлы блокировок</td></tr>
<tr><td>/var/run</td><td>PID процессов</td></tr>
<tr><td>/tmp</td><td>(temp) Временные файлы</td></tr>
<tr><td>/usr</td><td>(user applications) Программы пользователя</td></tr>
<tr><td>/usr/bin/</td><td>Исполняемые файлы</td></tr>
<tr><td>/usr/sbin/</td><td>Системные исполняемые файлы</td></tr>
<tr><td>/usr/lib/</td><td>Библиотеки</td></tr>
<tr><td>/usr/local</td><td>Файлы пользователя</td></tr>
<tr><td>/home</td><td>Домашняя папка</td></tr>
<tr><td>/boot</td><td>Файлы загрузчика</td></tr>
<tr><td>/lib</td><td>(library) Системные библиотеки</td></tr>
<tr><td>/opt</td><td>(Optional applications) Дополнительные программы</td></tr>
<tr><td>/mnt</td><td>(mount) Монтирование</td></tr>
<tr><td>/media</td><td>Съемные носители</td></tr>
<tr><td>/srv</td><td>(server) Сервер</td></tr>
<tr><td>/run</td><td>процессы</td></tr>
<tr><td>/sys</td><td>(system) Информация о системе</td></tr>

</tbody>
</table>


Дерево каталогов включает в себя несколько файловых систем, которые __монтируются__ в те или иные директории. Обычно структура приблизительно следующая:

Корень (`/`) - раздел на физическом диске
`/dev`, `/proc` - виртуальные файловые системы, обеспечивают работу ОС
`/boot` - зачастую отдельный раздел с загрузчиком ОС
`/media` - флешки всякие
`/mnt` - что хотите, то и примонтируете.
Несмотря на то, что дерево в целом выглядит как единая сущность, каждая ФС в дереве обычно отличается по физическому носителю, размеру и особенностям работы.

Несмотря на то, что дерево в целом выглядит как единая сущность, каждая **ФС** в дереве обычно отличается по физическому носителю, размеру и особенностям работы.
## Операции монтирования и отмонтирования
Для подключения файловой системы (*монтирования*) существует команда `mount`:
```sh
#mount шо куда:
#например
mount /dev/sda1 /mnt #подключаем устройство /dev/sda, это обычно первый раздел на первом винчестере в папку /mnt
# создаем файловую систему в оперативной памяти размером 512 мегабайт и подключаем её в папку /mnt. 
# Устройство в /dev при этом указывать не нужно, но параметр "шо" является обязательным, поэтому пишем tmpfs
mount -t tmpfs -o size=512m tmpfs /mnt/ 
```

`umount` отключает файловую систему. Ей можно указывать как устройство, так и папку. Однако если в этом папке будет та или иная программа, `umount` будет против и выведет ошибку
```sh
umount /mnt
umount -l /mnt # -l - значит lazy, "мне лень искать программу которая сейчас в этой файловой системе"
```

`mount` без параметров покажет все присоединенные **ФС**
![скринчик](http://shots.asmer.org.ua/2018_06_14__23_30_18.png)

### Файловые системы бывают разные
В отличие от, в linux есть удобные средства для создания своих файловых систем :
- `sshfs` - подключаете удаленную файловую систему по ssh и работаете в вашем рабочем окружении без постоянного переливания файлов по ftp/ssh/git
- `ftpfs` - аналог `sshfs`, только использует протокол **ftp**, работает не очень
- `btfs`  - подключает торрент файл. И можно сразу получить доступ к файлам. Не ожидая пока скачается.


### UNIX CLI _>

__CLI__ - очень крутая штука, особенно в UNIX-системах. Все это благодаря простоте, гибкости и мощности возможностей [shell](https://ru.wikipedia.org/wiki/Bash).

![asmer](http://shots.asmer.org.ua/2018_06_15__17_12_40.png)

Вы видите текст приглашения, и курсор для ввода команд.

#### Команды

Команды бывают внутренние (их реализует непосредственно программа-оболочка) или же другие программы, существующие в файловой системе.

Команды запускаются следующим образом:

![comands](http://shots.asmer.org.ua/2018_06_15__17_16_39.png)


#### Удобство CLI

Несмотря на то, что для среднего мышевоза нажимать кнопки на клавиатуре - непосильная задача, командно-строковой интерфейс обладает удобством, если знать его возможности. Не зря же многие мощные программные продукты имеют __CLI__ в том или ином виде (q3, hl, cs, autocad, linux, so on...)

Клавиатурные комбинации:

__TAB__ - святая кнопка, которая дополняет ваш текст. Не надо писать всё, надо жать TAB. Иногда два раза.
__CTRL-W__ - стереть слово до курсора
__CTRL-R__ - поиск по истории команд. Достаточно ввести любую часть другой команды что бы её выдернуть для использования сейчас.
__СТРЕЛКА ВВЕРХ__ - история
__Alt-B__ - слово назад.
Более того, современная библиотека readline, которая используется в bash и других консолях (например mysql), умеет работать в режиме vi или emacs.

Команда history выводит историю ваших команд.

### Создание и удаление файлов и директорий. touch, mkdir, rm, ls, cat, ...

Ниже идет джентльменский набор файловых операций, реализуемых командами:

`pwd` - (present working directory) показывает где мы сейчас находимся
`cd` - (change directory) сменить дерикторию
`mkdir` - (make dir) создать дерикторию
`rmdir` - (remove dir) удалить дерикторию
`cp` - (copy) копировать что либо
`mv` - (move) переместить что либо
`rm` - (remove) - удалить


#### Туда и обратно
```
cd ~/tmp # change directory: зайти в папку tmp в домашней папке текущего пользователя
cd       # идем в домашнюю папку
cd ./    # зайти в эту же папку
cd ../   # выйти на папку выше.

```

#### А есть че?
```
ls -la   # list подробно и с правами
ls       # list неподробно
ls -lah  # list подробно и с понятными размерами файлов

```

### Wildcard
Вы можете использовать символ `*` для замены части имени файла на любые:
`ls -la *php # показать все файлы php в директории`

При этом команда `ls` получит в качестве параметров **все файлы в папке, которые оканчиваются на php**.


#### Я хочу создать!

```

touch filename           # создает пустой файл filename, или обновляет время доступа к файлу ("касается" его)
mkdir ~/newFolder        # создаем папку в домашнем каталоге
mkdir newFolder          # создаем папку в текущем каталоге
mkdir ../newFolder       # создаем папку рядом с текущим (т. е. на уровень выше)
mkdir -p ~/newFolder/1/2/3/4/5/6 # создадим сразу несколько папок друг в друге

```

#### Переименовать или перенести:

```
mv ~/newFolder/1/2/3/4/5/6 ~/newFolder # перенесем папку 6 из папки 5 в папку ~/newFolder
mv filename otherFilename              # переименуем файл в другое имя файла.
```

#### Копировать

```
cp otherFilename filename             # копируем один файл из otherFilename в filename
cp -vrf ~/newFolder/1/2/ ~/newFolder  # copy verbose recursive force папку ~/newFolder/1/2 в ~/newFolder

```


![delete](https://cs6.pikabu.ru/images/big_size_comm/2017-07_5/1500953595190652479.jpg)


#### Удалить

```
rm otherFilename      # remove file otherFilename
rm -rf ~/newFolder/1  # remove files and directories recursively forced.

```

#### А что в файле?

```
cat /etc/resolv.conf # conCAT /etc/resolv.conf

```

#### Как __выйти__ из __Vim__ или о текстовых редакторах

Все мы в той или иной степени знакомы с редакторами текста. Однако в мире UNIX редакторы изначально более мощные и гибкие, ориентированные на работу с кодом или конфигурационными файлами.

##### `nano`

__nano__ - блокнот под __CLI__. имеет простой и понятный интерфейс, внизу есть подсказочки, все как вы ожидали в обычном простом редакторе. Символ ^ значит кнопку __CTRL__

![nano](http://shots.asmer.org.ua/2018_06_15__18_26_36.png)

##### `vim`

__ViM__ - (__vi__ i__m__proved) - мощный редактор, который построен не на идее редактирования текста, а на идее программирования редактирования текста. Благодаря этому вы при редактировании оперируете не отдельными символами, а сущностями, имеющими отношение к структуре программного кода (слова, параметры, парные тэги/скобки и так далее)

##### Режимы работы ViM;


* Нормальный. Это режим, в котором собственно происходит программирование текста

![vim keys](http://gitlab.a-level.com.ua/gitgod/Linux/raw/master/vi-vim-cheat-sheet.gif)

Каждая клавиша на клавиатуре в этом режиме отвечает за то или иное действие: перемещение, изменение, удаление, вставку, копирование блока текста и так далее.


##### Выход из ViM

* `Esc:q!` - выйти не сохраняясь
* `Esc:wqa` - выйти, сохранив все файлы
* `ZZ` - выход с сохранением.
* `Esc:x` - эквивалент `Esc:wq`


### Абсолютные и относительные пути, ~ и проч.

Пути бывают абсолютные и относительные, а так же относительно домашней папки(`/home/username`). Для этого используется следующий синтаксис:

`/etc/` - Путь, начинающийся со слеша - абсолютный
`tmp` - Путь без слеша означает путь относительно текущей папки. Иногда надо поставить ./ перед именем папки или файла (./tmp)
`~/` - домашняя папка. Обычно /home/username.
`~username` - домашняя папка пользователя.
`.., ../` - папка уровнем выше
`./` - текущая папка.

Каждый файл или папка в UNIX ОС имеют права доступа, которые побиты на 3 восьмеричных цифры (3 бита x 3 блока).

##### Права доступа

	- `r`- read
	- `w`- write
	- `x` -  eXecute/доступ к папке

Каждый из этих трех прав доступа назначаются:

* Владельцу
* Группе
* Остальным.
Для задания владельца используется команда __chown__ (__CH__ange __OWN__er):

```
chown username filename # меняем владельца
chown -R username:groupname ~/newFolder # меняем владельца и группу для папки ~/newFolder рекурсивно
```

Для задания прав доступа используется команда chmod

```
chmod 700 filename # полный доступ для владельца, ноль доступа группе и остальным
chmod -R a+x ~/newFolder # добавить всем доступ на запуск всем (владельцу, группе, и остальным) рекурсивно
```

## Hard & symlinks. 

В файловой системе есть ссылки двух типов - текстовые файлы с путем к другим файлам. Это симлинки. 
А так же есть копии файловых записей, которые ссылаются на контент файлов. Это хардлинки

Первые работают в разных файловых системах, однако если файл, на который сделана ссылка удалится - ссылка станет битая
Вторые работают только в одной файловой системе, однако все ссылки на контент файла **равноправны** и файловая система
ведет подсчет этих ссылок, освобождая место только после удаления **последней** ссылки.

для работы с этими ссылками используется команда `ln`.


##### Root

![root](https://sophosnews.files.wordpress.com/2016/11/root-1200.png?w=780&h=408&crop=1)

Так как Линукс это многопользовательская ОС то и должны быть определенные ограничения для пользователей

Таким ограничением являеться отстуствием прав root.

__root__ это кроме как корень еще и пользователь системы

Пользователю __root__ позволено все: удалять, копировать или записывать или запускать любой файл которые находиться в системе

Пользователь __root__ имеет наивысшие привелегии на все.

То есть __root__ это полноценный администратор машины(компьютера).

Если вам надо установить программу или поправить конфигурации вам нужно зайти под этим пользователем в систему.

Но это __НЕ РЕКОМЕНДУЕТСЯ!!!__

*Сидеть под рутом* отчасти опасно так как вы можете случайно сделать что то не то и вы можете попращаться с системой. 

##### Выход есть!

[__sudo__](https://ru.wikipedia.org/wiki/Sudo) -- *substitute user and do*, дословно «подменить пользователя и выполнить»

Специальная программа которая позволяет запускать небольшие сессии под рутом от обычного пользователя что бы улучшить общее состояние безопасности и дать вам второй шанс если вы вдруг чего то недосмотрели

Для того что бы иметь такие права вам все равно придется раз зайти под рутом

Правила, используемые __sudo__ для принятия решения о предоставлении доступа, находятся в файле `/etc/sudoers` (для редактирования файла можно использовать специальный редактор visudo, запускаемый из командной строки без параметров, в том числе без указания пути к файлу); язык их написания и примеры использования подробно изложены в man sudoers(5).


